/**
 * Template Exporter
 *
 * Handles template export to HTML and JSON formats with responsive support
 */

import type {
  Template,
  TemplateExportOptions,
  ComponentTreeNode,
} from '../types/template.types';
import type { BaseComponent, BaseStyles } from '../types/component.types';
import { ComponentTreeBuilder } from './ComponentTreeBuilder';
import { BreakpointManager } from '../responsive/BreakpointManager';
import { DeviceType, BreakpointStrategy } from '../types/responsive.types';
import type { ResponsiveStyles } from '../types/responsive.types';

/**
 * Export result
 */
export interface ExportResult {
  html?: string;
  json?: string;
  format: 'html' | 'json' | 'both';
}

/**
 * Template Exporter Service
 *
 * Exports templates to various formats (HTML, JSON) with customization options
 * Supports responsive design with media query generation
 */
export class TemplateExporter {
  private treeBuilder: ComponentTreeBuilder;
  private breakpointManager: BreakpointManager;

  constructor() {
    this.treeBuilder = new ComponentTreeBuilder();
    this.breakpointManager = new BreakpointManager();
  }

  /**
   * Export template
   *
   * @param template - Template to export
   * @param options - Export options
   * @returns Export result
   */
  export(template: Template, options: TemplateExportOptions): ExportResult {
    const result: ExportResult = {
      format: options.format,
    };

    if (options.format === 'html' || options.format === 'both') {
      result.html = this.exportHTML(template, options);
    }

    if (options.format === 'json' || options.format === 'both') {
      result.json = this.exportJSON(template, options);
    }

    return result;
  }

  /**
   * Export template as HTML
   *
   * @param template - Template to export
   * @param options - Export options
   * @returns HTML string
   */
  private exportHTML(
    template: Template,
    options: TemplateExportOptions
  ): string {
    const { settings, components } = template;

    // Build component tree if not present
    const tree =
      template.componentTree || this.treeBuilder.buildTree(components);

    // Generate HTML parts
    const htmlContent = this.generateHTMLContent(tree, template, options);

    // Build complete HTML document
    let html = '';

    if (options.includeComments) {
      html += `<!-- Generated by Email Builder -->\n`;
      html += `<!-- Template: ${template.metadata.name} -->\n`;
      html += `<!-- Version: ${template.metadata.version} -->\n\n`;
    }

    html += '<!DOCTYPE html>\n';
    html += `<html lang="${settings.locale || 'en'}"${settings.rtl ? ' dir="rtl"' : ''}>\n`;
    html += '<head>\n';
    html += '  <meta charset="UTF-8">\n';
    html += '  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n';

    if (template.metadata.description) {
      html += `  <meta name="description" content="${this.escapeHTML(template.metadata.description)}">\n`;
    }

    html += `  <title>${this.escapeHTML(template.metadata.name)}</title>\n`;

    // Add styles
    if (!options.inlineStyles) {
      html += '  <style>\n';
      html += this.generateCSS(template, options);
      html += '  </style>\n';
    }

    html += '</head>\n';
    html += '<body>\n';

    // Add canvas wrapper
    const canvasStyles = this.buildCanvasStyles(template, options);
    html += `  <div class="email-canvas"${canvasStyles ? ` style="${canvasStyles}"` : ''}>\n`;
    html += htmlContent;
    html += '  </div>\n';

    html += '</body>\n';
    html += '</html>';

    // Minify if requested
    if (options.minify) {
      html = this.minifyHTML(html, options.includeComments);
    }

    // Pretty print if requested
    if (options.prettyPrint && !options.minify) {
      html = this.prettyPrintHTML(html);
    }

    return html;
  }

  /**
   * Export template as JSON
   *
   * @param template - Template to export
   * @param options - Export options
   * @returns JSON string
   */
  private exportJSON(
    template: Template,
    options: TemplateExportOptions
  ): string {
    const data = {
      ...template,
      exportedAt: Date.now(),
    };

    return JSON.stringify(data, null, options.prettyPrint ? 2 : 0);
  }

  /**
   * Generate HTML content from component tree
   */
  private generateHTMLContent(
    tree: ComponentTreeNode[],
    template: Template,
    options: TemplateExportOptions
  ): string {
    let html = '';

    const renderNode = (node: ComponentTreeNode, indent = 2): string => {
      const { component } = node;
      const indentStr = ' '.repeat(indent);
      let nodeHTML = '';

      if (options.includeComments) {
        nodeHTML += `${indentStr}<!-- Component: ${component.type} (${component.id}) -->\n`;
      }

      // Generate component HTML
      const componentHTML = this.generateComponentHTML(
        component,
        template,
        options
      );

      // Add indentation
      const lines = componentHTML.split('\n');
      nodeHTML += lines.map((line) => (line ? `${indentStr}${line}` : line)).join('\n');

      // Render children
      if (node.children.length > 0) {
        nodeHTML += '\n';
        node.children.forEach((child) => {
          nodeHTML += renderNode(child, indent + 2);
        });
      }

      return nodeHTML + '\n';
    };

    tree.forEach((node) => {
      html += renderNode(node);
    });

    return html;
  }

  /**
   * Generate HTML for individual component
   */
  private generateComponentHTML(
    component: BaseComponent,
    template: Template,
    options: TemplateExportOptions
  ): string {
    const { type, content, styles } = component;

    // Build component attributes
    const attrs: string[] = [
      `class="component component-${type}"`,
      `data-component-id="${component.id}"`,
    ];

    // Add inline styles if requested
    if (options.inlineStyles) {
      const inlineStyles = this.buildInlineStyles(styles, template);
      if (inlineStyles) {
        attrs.push(`style="${inlineStyles}"`);
      }
    }

    const attrString = attrs.join(' ');

    // Generate component-specific HTML based on type
    switch (type) {
      case 'button':
        return this.generateButtonHTML(content, attrString);

      case 'text':
        return this.generateTextHTML(content, attrString);

      case 'image':
        return this.generateImageHTML(content, attrString);

      case 'separator':
        return this.generateSeparatorHTML(attrString);

      case 'spacer':
        return this.generateSpacerHTML(content, attrString);

      case 'header':
      case 'footer':
      case 'hero':
      case 'cta':
        return this.generateSectionHTML(type, content, attrString);

      case 'list':
        return this.generateListHTML(content, attrString);

      default:
        return this.generateGenericHTML(content, attrString);
    }
  }

  /**
   * Generate button HTML
   */
  private generateButtonHTML(content: Record<string, unknown>, attrs: string): string {
    const text = content['text'] || 'Button';
    const href = content['href'] || '#';
    return `<a href="${this.escapeHTML(String(href))}" ${attrs}>${this.escapeHTML(String(text))}</a>`;
  }

  /**
   * Generate text HTML
   */
  private generateTextHTML(content: Record<string, unknown>, attrs: string): string {
    const text = content['text'] || '';
    const tag = content['tag'] || 'p';
    return `<${tag} ${attrs}>${this.escapeHTML(String(text))}</${tag}>`;
  }

  /**
   * Generate image HTML
   */
  private generateImageHTML(content: Record<string, unknown>, attrs: string): string {
    const src = content['src'] || '';
    const alt = content['alt'] || '';
    return `<img src="${this.escapeHTML(String(src))}" alt="${this.escapeHTML(String(alt))}" ${attrs}>`;
  }

  /**
   * Generate separator HTML
   */
  private generateSeparatorHTML(attrs: string): string {
    return `<hr ${attrs}>`;
  }

  /**
   * Generate spacer HTML
   */
  private generateSpacerHTML(content: Record<string, unknown>, attrs: string): string {
    const height = content['height'] || '20px';
    return `<div ${attrs} style="height: ${height};"></div>`;
  }

  /**
   * Generate section HTML (header, footer, hero, cta)
   */
  private generateSectionHTML(
    _type: string,
    content: Record<string, unknown>,
    attrs: string
  ): string {
    const innerContent = content['html'] || content['text'] || '';
    return `<section ${attrs}>\n  ${innerContent}\n</section>`;
  }

  /**
   * Generate list HTML
   */
  private generateListHTML(content: Record<string, unknown>, attrs: string): string {
    const items = (content['items'] as string[]) || [];
    const ordered = content['ordered'] || false;
    const tag = ordered ? 'ol' : 'ul';

    let html = `<${tag} ${attrs}>\n`;
    items.forEach((item) => {
      html += `  <li>${this.escapeHTML(item)}</li>\n`;
    });
    html += `</${tag}>`;

    return html;
  }

  /**
   * Generate generic HTML for unknown component types
   */
  private generateGenericHTML(content: Record<string, unknown>, attrs: string): string {
    const text = JSON.stringify(content);
    return `<div ${attrs}>${this.escapeHTML(text)}</div>`;
  }

  /**
   * Generate CSS for template with responsive media queries
   */
  private generateCSS(template: Template, _options: TemplateExportOptions): string {
    const { generalStyles, settings, components } = template;
    let css = '';

    // Reset styles
    css += '    * { margin: 0; padding: 0; box-sizing: border-box; }\n';
    css += '    body { font-family: Arial, sans-serif; }\n\n';

    // Canvas styles (base/desktop)
    css += '    .email-canvas {\n';
    if (generalStyles?.canvasBackgroundColor) {
      css += `      background-color: ${generalStyles.canvasBackgroundColor};\n`;
    }
    if (generalStyles?.canvasBorder) {
      css += `      border: ${generalStyles.canvasBorder};\n`;
    }
    if (settings.canvasDimensions?.width) {
      css += `      width: ${settings.canvasDimensions.width}px;\n`;
      css += `      max-width: 100%;\n`;
    }
    css += '      margin: 0 auto;\n';
    css += '    }\n\n';

    // Component base styles
    css += '    .component {\n';
    css += '      display: block;\n';
    if (generalStyles?.defaultComponentBackgroundColor) {
      css += `      background-color: ${generalStyles.defaultComponentBackgroundColor};\n`;
    }
    css += '    }\n\n';

    // Generate responsive media queries
    css += this.generateResponsiveMediaQueries(template, components);

    return css;
  }

  /**
   * Generate responsive media queries for all components
   */
  private generateResponsiveMediaQueries(
    _template: Template,
    components: BaseComponent[]
  ): string {
    let css = '';

    // Check if any component has responsive config
    const hasResponsiveComponents = components.some(
      (c) => c.responsive?.enabled && c.responsive.styles
    );

    if (!hasResponsiveComponents) {
      return css;
    }

    // Use desktop-first strategy by default (works better for web)
    const strategy = BreakpointStrategy.DESKTOP_FIRST;

    // Generate media queries for each device (mobile, tablet)
    // Desktop is the base, so we only need queries for smaller devices
    const devices = [DeviceType.TABLET, DeviceType.MOBILE];

    for (const device of devices) {
      const mediaQuery = this.breakpointManager.generateMediaQuery(device, strategy);

      if (!mediaQuery) continue;

      // Collect all components with responsive styles for this device
      const deviceStyles: string[] = [];

      for (const component of components) {
        if (!component.responsive?.enabled || !component.responsive.styles) {
          continue;
        }

        const componentCss = this.generateResponsiveComponentCSS(
          component,
          device,
          component.responsive.styles
        );

        if (componentCss) {
          deviceStyles.push(componentCss);
        }
      }

      // Only add media query if there are styles for this device
      if (deviceStyles.length > 0) {
        css += `\n    /* ${device.charAt(0).toUpperCase() + device.slice(1)} Styles */\n`;
        css += `    ${mediaQuery} {\n`;
        deviceStyles.forEach((style) => {
          css += style;
        });
        css += '    }\n';
      }
    }

    return css;
  }

  /**
   * Generate responsive CSS for a specific component and device
   */
  private generateResponsiveComponentCSS(
    component: BaseComponent,
    device: DeviceType,
    responsiveStyles: ResponsiveStyles
  ): string {
    let css = '';
    const selector = `      [data-component-id="${component.id}"]`;
    const styles: string[] = [];

    // Padding
    if (responsiveStyles.padding) {
      const padding = responsiveStyles.padding;
      if (padding.top?.[device]) {
        const val = padding.top[device];
        styles.push(`padding-top: ${this.breakpointManager.cssValueToString(val)}`);
      }
      if (padding.right?.[device]) {
        const val = padding.right[device];
        styles.push(`padding-right: ${this.breakpointManager.cssValueToString(val)}`);
      }
      if (padding.bottom?.[device]) {
        const val = padding.bottom[device];
        styles.push(`padding-bottom: ${this.breakpointManager.cssValueToString(val)}`);
      }
      if (padding.left?.[device]) {
        const val = padding.left[device];
        styles.push(`padding-left: ${this.breakpointManager.cssValueToString(val)}`);
      }
    }

    // Margin
    if (responsiveStyles.margin) {
      const margin = responsiveStyles.margin;
      if (margin.top?.[device]) {
        const val = margin.top[device];
        styles.push(`margin-top: ${this.breakpointManager.cssValueToString(val)}`);
      }
      if (margin.right?.[device]) {
        const val = margin.right[device];
        styles.push(`margin-right: ${this.breakpointManager.cssValueToString(val)}`);
      }
      if (margin.bottom?.[device]) {
        const val = margin.bottom[device];
        styles.push(`margin-bottom: ${this.breakpointManager.cssValueToString(val)}`);
      }
      if (margin.left?.[device]) {
        const val = margin.left[device];
        styles.push(`margin-left: ${this.breakpointManager.cssValueToString(val)}`);
      }
    }

    // Font size
    if (responsiveStyles.fontSize?.[device]) {
      const val = responsiveStyles.fontSize[device];
      styles.push(`font-size: ${this.breakpointManager.cssValueToString(val)}`);
    }

    // Width
    if (responsiveStyles.width?.[device]) {
      const val = responsiveStyles.width[device];
      styles.push(`width: ${this.breakpointManager.cssValueToString(val)}`);
    }

    // Height
    if (responsiveStyles.height?.[device]) {
      const val = responsiveStyles.height[device];
      styles.push(`height: ${this.breakpointManager.cssValueToString(val)}`);
    }

    // Text align
    if (responsiveStyles.textAlign?.[device]) {
      styles.push(`text-align: ${responsiveStyles.textAlign[device]}`);
    }

    // Display
    if (responsiveStyles.display?.[device]) {
      styles.push(`display: ${responsiveStyles.display[device]}`);
    }

    // Only generate CSS if there are styles for this device
    if (styles.length > 0) {
      css += `${selector} {\n`;
      styles.forEach((style) => {
        css += `        ${style};\n`;
      });
      css += '      }\n';
    }

    return css;
  }

  /**
   * Build canvas inline styles
   */
  private buildCanvasStyles(
    template: Template,
    options: TemplateExportOptions
  ): string {
    if (!options.inlineStyles) {
      return '';
    }

    const { generalStyles, settings } = template;
    const styles: string[] = [];

    if (generalStyles?.canvasBackgroundColor) {
      styles.push(`background-color: ${generalStyles.canvasBackgroundColor}`);
    }
    if (generalStyles?.canvasBorder) {
      styles.push(`border: ${generalStyles.canvasBorder}`);
    }
    if (settings.canvasDimensions?.width) {
      styles.push(`width: ${settings.canvasDimensions.width}px`);
      styles.push('max-width: 100%');
    }
    styles.push('margin: 0 auto');

    return styles.join('; ');
  }

  /**
   * Build inline styles from component styles
   */
  private buildInlineStyles(
    styles: BaseStyles,
    _template: Template
  ): string {
    const cssProps: string[] = [];

    if (styles.backgroundColor) {
      cssProps.push(`background-color: ${styles.backgroundColor}`);
    }

    if (styles.padding) {
      const { top, right, bottom, left } = styles.padding;
      cssProps.push(
        `padding: ${top.value}${top.unit} ${right.value}${right.unit} ${bottom.value}${bottom.unit} ${left.value}${left.unit}`
      );
    }

    if (styles.margin) {
      const { top, right, bottom, left } = styles.margin;
      cssProps.push(
        `margin: ${top.value}${top.unit} ${right.value}${right.unit} ${bottom.value}${bottom.unit} ${left.value}${left.unit}`
      );
    }

    if (styles.width) {
      cssProps.push(`width: ${styles.width.value}${styles.width.unit}`);
    }

    if (styles.height) {
      cssProps.push(`height: ${styles.height.value}${styles.height.unit}`);
    }

    if (styles.border) {
      const { width, style, color, radius } = styles.border;
      cssProps.push(`border: ${width.value}${width.unit} ${style} ${color}`);

      if (radius) {
        const { topLeft, topRight, bottomRight, bottomLeft } = radius;
        cssProps.push(
          `border-radius: ${topLeft.value}${topLeft.unit} ${topRight.value}${topRight.unit} ${bottomRight.value}${bottomRight.unit} ${bottomLeft.value}${bottomLeft.unit}`
        );
      }
    }

    if (styles.customStyles) {
      Object.entries(styles.customStyles).forEach(([key, value]) => {
        cssProps.push(`${key}: ${value}`);
      });
    }

    return cssProps.join('; ');
  }

  /**
   * Minify HTML
   */
  private minifyHTML(html: string, keepComments: boolean): string {
    // Remove comments if not keeping them
    if (!keepComments) {
      html = html.replace(/<!--[\s\S]*?-->/g, '');
    }

    // Remove extra whitespace
    html = html.replace(/>\s+</g, '><');
    html = html.replace(/\s{2,}/g, ' ');
    html = html.trim();

    return html;
  }

  /**
   * Pretty print HTML
   */
  private prettyPrintHTML(html: string): string {
    // Simple pretty printing (basic implementation)
    let formatted = '';
    let indent = 0;
    const lines = html.split('\n');

    lines.forEach((line) => {
      const trimmed = line.trim();
      if (!trimmed) return;

      // Decrease indent for closing tags
      if (trimmed.startsWith('</')) {
        indent = Math.max(0, indent - 1);
      }

      formatted += ' '.repeat(indent * 2) + trimmed + '\n';

      // Increase indent for opening tags (except self-closing and inline)
      if (
        trimmed.startsWith('<') &&
        !trimmed.startsWith('</') &&
        !trimmed.endsWith('/>') &&
        !trimmed.match(/<(img|hr|br|meta|link)/)
      ) {
        indent++;
      }
    });

    return formatted;
  }

  /**
   * Escape HTML special characters
   */
  private escapeHTML(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;',
    };

    return text.replace(/[&<>"']/g, (char) => map[char] ?? char);
  }
}
